设计思想：通过把cumsum的值分散保存在idx在树中的路径上，并用位运算映射树结构，使检索更新cumsum快速简单

例子：下图圆圈中蓝字为下标idx，黑字为值tree[idx]。红线指向后继next，黑线指向parent.
TODO: add image

结点关系映射：
第k层的index有k位1. 
黑线－从子结点到父结点index的映射: parent(n) = n & (n-1)，即最后一位置0.
红线－从结点到它后继结点的映射：   next(n) = n + (n & -n).  左移最后一位1,或把最后一段0111...11结构变为1000...00

例子：
idx         0     1     2     3     4     5     6     7     8     9    10    11     12
(binary)    0     1    10    11   100   101   110   111  1000  1001  1010  1011   1100
parent[idx] -     0     0     2     0     4     4     6     0     8     8    10      8
(binary)    -     0     0    10     0   100   100   110     0  1000  1000  1010   1000
next[idx]   -     2     4     4     8     6     8     8     -    10    12    12      -
(binary)    -    10   100   100  1000   1q0  1000  1000     -  1010  1100  1100      -

对后继映射的进一步解释：
后继结点定义为下一个兄弟结点，或如果当前结点n是父亲的最右结点，后继是n第一个非最右结点祖先的后继结点。
对第一种情况，注意到(n&-n)取了n最右一位就可以得到结论。对第二种情况，注意到所有最右结点都以x0 11...1100..00结尾，它的祖先结点中最低的不是最右结点的key是x0 10...0，而它的右结点值是x1 00...1100..00，正好还是n + (n & -n)。

数据映射
tree[idx] = cumsum[idx] - cumsum[parent[idx]]
例如上图对应下表：
idx         0     1     2     3     4     5     6     7     8     9    10    11     12
input[idx]  2     1     1     3     2     3     4     5     6     7     8     9
cumsum[idx] 0     2     3     4     7     9    12    16    21    27    34    42     51
tree[idx]   0     2     3     1     7     2     5     4     9     6    13     8     30

初始化：tree[idx]初始化为长为数组长度+1的全零数组。
检索：检索cumsum只需把node n+1路径上所有结点加起来，求range sum就是两个cumsum之差。
更新input[n]：假设增加d, 影响的元素是结点n+1以及它到根结点路径上所有结点的后续兄弟结点。这些元素都需要加d
例如更新input[4]，则需更新结点5(对应input[4]), 6, 8.

最后注意Fenwick tree不直接存储data，因此如果问题需要access data方便起见最好另存一份。
